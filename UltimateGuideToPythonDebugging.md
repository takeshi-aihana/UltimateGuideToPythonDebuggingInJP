# Python をデバッグするための究極のガイド

* (原文: [Ultimate Guide to Python Debugging](https://martinheinz.dev/blog/24)/)

---

## はじめに

たとえ分かりやすく読みやすいコードを書いたとしても、あるいは様々なテストでコードを検証していようと、もしくはあなたが経験豊富な開発者であったとしても、不可解なバグはいや応無しに現れるので何らかの方法でデバッグする必要が出てきます。
多くのひとたちは自分のコードで起こったことを確認するのにたくさんの ``print`` 文に頼っています。
このアプローチは「理想的」とはほど遠く、コードのどこに問題があるのかを探し出すためにもっと良い方法がたくさんあります。
この記事では、それらのいくつかを紹介します。

---

## ログの取得は必須です

本稿では、**i386プラットホームの ``gcc`` コンパイラ** を使用してC言語のコードがアセンブリ言語へどのように「翻訳」されるのかを解説します。
また C言語のほぼ全ての言語構造の「翻訳」についても説明します。

* 事前の知識：
C言語と少しだけアセンブリ言語

* アセンブリ言語の文法について：
本稿で使用するアセンブリ言語の文法は GNU アセンブラ（GAS）のものなので注意して下さい。
この文法は MASM や NASM のそれとは異なります。

    * 主な違いは次の通り：

        * NASM または MASM の場合     ```命令 dest, src```
        * GAS の場合                  ```命令 src, dest```

    * 本稿を読む前に、読者は GNU アセンブラの文法に慣れ親しんでおく必要があります。

* 対象とする読者：
  * C言語のコードをアセンブリ言語に翻訳する方法に興味のある方
  * C言語とアセンブラでコードを記述するシステム・プログラマ
  * C言語で作成したバイナリのリバースエンジニアリングをしてみたいと考えている方

---

## プログラムの構造

簡単な C言語のプログラムの例を使って、実行時にプログラムがメモリの中にロードされた時の状態を見てみることにしましょう。

これが簡単な C言語のプログラムです：

```C
int globalVar;

void main()
{
        globalVar = 10;
}

```

このプログラムで注目したい点が二つあります。
それは「グローバル変数」と「関数」です。
関数には実行できるコードが含まれており、グローバル変数には何かデータが格納されています。
このプログラムが機械語に「翻訳」されてメモリにロードされる時、ランダム・アクセス・メモリ（RAM）の中には「データ（Data）」と「コード（Code）」を格納するための領域がそれぞれ確保されます。

![](images/programstructure.png)

「データ（Data）」の領域にはグローバル変数のために確保された数バイトの領域が含まれ、「コード（Code）」の領域は関数のコードから生成された命令をロードするために確保された数バイトの領域が含まれます。
CPU がこれらの命令を実行し、データを処理します。

次に、このプログラム用に生成した実際のアセンブリ言語のコードを見てみることにしましょう：

```asm
        .comm   globalVar,4,4
        .text
.globl main
        .type   main, @function
main:
        pushl   %ebp
        movl    %esp, %ebp
        movl    $10, globalVar
        popl    %ebp
        ret
```

このコードにコメントを入れたものが、こちらです：

```asm
# これがグローバル変数の宣言
# .comm は初期化していないデータを宣言するための識別子
# アセンブラは .bss セグメントの中に、ここに示したサイズの領域を確保する
        .comm   globalVar,4,4
# .text セグメントは、ここから始まる
        .text
# main という関数名を公開することで、このファイルの外から main 関数を呼び出すことができる
.globl main
        .type   main, @function
# 生成した main 関数のコード
main:
        pushl   %ebp
        movl    %esp, %ebp
        movl    $10, globalVar
        popl    %ebp
        ret
```

### セクションとセグメント

「セクション」は、プログラムのリンク時に必要となる情報を格納したオブジェクト・ファイルの中にある領域を示します。
セクションには、リンカが実行形式のバイナリを生成するために使用するデータが含まれています。
例えば、あるセクションにはプログラムのコードやグローバル変数、再配置テーブルなどを格納することができます。
そして「セグメント」はセクションに似ていますが、これが実際にプログラムを実行する際にメモリに格納される領域です。
実行可能なバイナリにはたくさんのセグメントが含まれており、それらはプログラムを実行する時にローダによってメモリにロードされます。
セクションとセグメントには ``.text`` とか ``.data`` とか ``.bss`` といった名前が付いています。

ここに、C言語のコードからアセンブリ言語のコードを生成する場面でよく使用するセクションやセグメントを例として上げてみました：
* ``.text`` => ここには実行可能な命令が格納される。
* ``.bss`` => ここには初期化されていない（全てのビットが0にセットされている）データが格納される。通常は、初期化されていないスタティック変数とグローバル変数が格納される。プログラムからこのセクションにデータを書き込むことができる。
* ``.data`` => ここには初期化されたグローバル変数が格納される。例えば ``int x = 20;`` とグローバル宣言するとここに格納される。プログラムからこのセクションにデータを書き込むことができる。

``.bss`` と ``.data`` セクションはほぼ同じです。
唯一の違いはプログラムがロードされた時に確保したメモリの初期値です。
``.bss`` セグメントは全てのビットが 0 であり、``.data`` セグメントは C言語のコードで宣言されていた値です。

* ``.rodata`` => ここには読み込み専用のデータが格納される。このセグメントは、プログラムがロードされた時にメモリにロードされ、プログラムからは変更することができない領域である。通常、これは文字列の定数が格納される。

オブジェクト・ファイルや実行可能なファイルには他にもいろいろなセクションが存在しますが、それらの多くはプログラムの実行時にメモリにはロードされません。
例えば ``.debug`` セグメントにはデバッガが必要とする情報しか格納されていません。
また、いくつかのセクションはオブジェクト・モジュールにしか存在せず、あとで別のセクションと結合されるというものもあります。
そのようなものには、例えば ``.common`` セクションがあります。

---

## スタックとローカル変数

再び、この簡単な C言語のプログラムから始めることにしましょう：

```C
int globalVar;

void main()
{
        globalVar = 10;
}

```

このプログラムにはグローバル変数が一つあります。
これまで見てきたように、グローバル変数は ``.data`` セグメントの中に確保されます。
それじゃあローカル変数はどうでしょうか？
ローカル変数は「スタック」の中に確保されます。
ひとたび関数の処理が終了してしまえば、ローカル変数は解放されてしまいます。

スタックを持つプログラム構造は、このように見えます：

![](images/progwithstack.png)

「スタック」は、プログラム内のスタック領域に割当てられているメモリのことで、領域を確保する度にその境界線がアドレスの高位から低位へ向かって伸びていきます。
では別のサンプル・コードでスタックがどのように使用されるかを見てみることにしましょう。

```C
void fun()
{
	int locVar = 0;
	locVar++;
}
```
このプログラムは、次のスタック操作に似たコードに変換されます：

```
fun:
  stack_top -= 4
  stack_top[0] = 0
  stack_top[0] ++
  stack_top += 4
  return
```

まず関数を処理する前、スタックの境界線を示す ``stack_top`` はスタックの先頭を指していました。
関数の先頭で ``stack_top`` は -4バイトされ（4バイト分だけ低位へ向かって進み）、これによって事実上確保された 4バイトの領域がローカル変数の ``locVar`` によって使用されることになります。
そして関数から ``return`` する直前で、再び ``stack_top`` は関数を処理する前の位置を指すようになります。
このサンプル・コードにはローカル変数は一つだけしかありません。
もしローカル変数がもっとたくさんあったとしたら、``stack_top`` はその変数分だけ減らされることで、全てのローカル変数が融通されるようになります。

**注記：**

ここで実際に減らされるバイト数は要求されたものよりも大きくなるかもしれません（全てのローカル変数が要求したメモリ領域の合計になるので）。
これは、次に示す二つの理由の可能性があります：

 1. アーキテクチャの制限
 2. 一部のアーキテクチャでは高速化のためにコードを最適化するものがある（``stack_top`` が16バイト単位で移動する等）

次に、``gcc`` が生成した実際のアセンブリ言語のコードを見てみることにしましょう：

```asm
fun:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	$0, -4(%ebp)
	addl	$1, -4(%ebp)
	leave
	ret
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# fun 関数の先頭
fun:

# 現在の ebp レジスタの値を push する（実際には ebp レジスタの値をスタックに「退避」する）。
# この「退避」は、あとで ebp レジスタの値を変更するために実施する。
# この関数が終了したら、スタックから ebp レジスタの値をリストアする。
# これにより、関数の最後に到達した時点で ebp レジスタの値は元の値に戻る。
	pushl	%ebp

# ここで現在のスタック・ポインタの値を ebp レジスタに移動する。
	movl	%esp, %ebp

# 現在のスタック・ポインタの値を減らす。
# この操作によって確保された領域が、この関数内で宣言されたローカル変数のために使用される。
# 
# このサンプル・コードではローカル変数は一つだけなので、普通ならば 4バイトで十分なのに、スタックは 16バイト減らされている。
# 前にも述べたように、パフォーマンス上の理由などで esp レジスタの値を 16バイト単位で移動させている。
# それ以外の領域は、この関数を処理している間は使用されない。
# 
# ここで 4バイトのサイズのローカル変数が二つあると仮定すると、同じ理由で esp レジスタの値がそれぞれ 16バイトずつ減っていくことになるが
# その分だけ未使用の領域は少なくなる。
	subl	$16, %esp

# '-4(%ebp)' はローカル変数 locVar の値が格納されているメモリの場所なので、これに 0 をセットする。
	movl	$0, -4(%ebp)

# ローカル変数の locVar の値をインクリメントする。
	addl	$1, -4(%ebp)

# ここで ebp レジスタの値をスタックからリストアして、この関数の呼出元に返る。
#   'leave' 命令は次の二つの命令を行う：
#      move %ebp %esp
#      pop %ebp
	leave
	ret
```

ここにあるスタックの図は上のコードを説明するものです：


![](images/localvars.png)


**課題：**
同様に、次の状態を説明するスタックの図を書いてみましょう
「もし関数からローカル変数のポインタが返されたら何が起こるか？」

---

## 算術演算の翻訳

どのように計算式がアセンブリ言語のコードに「翻訳」されるのかを見ていくことにしましょう。
この C言語のコードを例にとります：

```C
        int a = 2;
        int b = 3;
        int c = 24;
        a = a + b;
        aa = a + b * c;
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$2, -4(%ebp)
	movl	$3, -8(%ebp)
	movl	$24, -12(%ebp)
	movl	-8(%ebp), %eax
	addl	%eax, -4(%ebp)
	movl	-8(%ebp), %eax
	imull	-12(%ebp), %eax
	addl	%eax, -4(%ebp)
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    c => (ebp - 12) => -12(%ebp)
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# a = 2
	movl	$2, -4(%ebp)
# b = 3
	movl	$3, -8(%ebp)
# c = 24
	movl	$24, -12(%ebp)
# tmp = b
movl	-8(%ebp), %eax

（つづく）
```

i386 アーキテクチャには一つの命令に対して指定できるメモリ・アドレスの数に制限があります。
一個の命令で任意の数のメモリ・アドレスを使用することはできません。
そのため一時的な格納場所としてレジスタを使用します。
複数のレジスタを使って数値演算やその他の演算を行います。
レジスタの一般的な使い方は、最初にメモリの内容をレジスタに取り込み、レジスタ同士で何か操作してから、レジスタの値をメモリに格納するというものです。
次のサンプルでは、``eax`` レジスタを一時的な保管場所として使用しています。
上のコメントでは ``tmp`` が ``eax`` レジスタを表します。


```asm
(つづき）

# a = a + tmp
	addl	%eax, -4(%ebp)
# tmp = b
	movl	-8(%ebp), %eax
# tmp = tmp * c
	imull	-12(%ebp), %eax
# a = tmp + a
	addl	%eax, -4(%ebp)
```

**課題：**
算術式に"（）"が含まれている場合、どのようにアセンブリ言語のコードに翻訳されるのか？

---

## ビット演算の翻訳

この C言語のコードを例にとります。これは何かの関数の中から抜粋したコードです：

```C
        int a = 4;
        int b = 8;
        int c = a | b;
        int d = b & c;
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    c => (ebp - 12) => -12(%ebp)
    d => (ebp - 16) => -16(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

これが生成したアセンブリ言語のコードです：

```asm
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	-8(%ebp), %eax
	movl	-4(%ebp), %edx
	orl	%edx, %eax
	movl	%eax, -12(%ebp)
	movl	-12(%ebp), %eax
	movl	-8(%ebp), %edx
	andl	%edx, %eax
	movl	%eax, -16(%ebp)
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# a = 4
	movl	$4, -4(%ebp)

# b = 8
	movl	$8, -8(%ebp)

# tmp = b
	movl	-8(%ebp), %eax

# tmp2 = a
	movl	-4(%ebp), %edx

# tmp = tmp | tmp2
	orl	%edx, %eax

# c = tmp
	movl	%eax, -12(%ebp)

# tmp = c
	movl	-12(%ebp), %eax

# tmp2 = b
	movl	-8(%ebp), %edx

# tmp = tmp & tmp2
	andl	%edx, %eax

# d = tmp
	movl	%eax, -16(%ebp)
```

（ローカル）変数の中身がそれぞれレジスタに移動され、ビット演算の命令（このサンプルの場合だと ``andl`` と ``olr``）を使用したあと、その結果をメモリに戻しています。

---

## 分岐処理の翻訳

#### <u>IF-ELSE 文</u>

この C言語のコードを例にとります。これは何かの関数の中から抜粋したコードです：

```C
	int a = 4;
	int b = 8;
	int d = 0;

	if (a > b) {
		d = 1;
	}
	else {
		d = 2;
	}
```

そして生成したアセンブリ言語のコードが、こちら：

```asm
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)
	movl	-4(%ebp), %eax
	cmpl	-8(%ebp), %eax
	jle	.L2
	movl	$1, -12(%ebp)
	jmp	.L1
.L2:
	movl	$2, -12(%ebp)
.L1:
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    d => (ebp - 12) => -12(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# a = 4
	movl	$4, -4(%ebp)

# b = 8
	movl	$8, -8(%ebp)

# d = 0
	movl	$0, -12(%ebp)

# tmp = a
	movl	-4(%ebp), %eax

# b と tmp を比較する
	cmpl	-8(%ebp), %eax

# もし tmp が b よりも小さいかまたは等しい場合は
# ラベル L2 （C言語のコードで言うと else ブロック）へジャンプする
	jle	.L2

# ここから if ブロック
# d = 1
	movl	$1, -12(%ebp)

# ここが if ブロックの最後の命令
# else ブロックの先にある命令（ラベル L1）へジャンプする
	jmp	.L1

# ここから else ブロック（ラベル L2）
.L2:

# d = 2
	movl	$2, -12(%ebp)

# ここで else ブロックは終了
# ここが else ブロック直後の命令
.L1:
```

#### <u>SWITCH-CASE 文</u>

この C言語のコードを例にとります。これは何かの関数の中から抜粋したコードです：

```C
	int a = 4;
	int b = 8;
	int d = 0;

	switch (b) {
	case 2:
		a++;
		break;
	case 8:
		b++;
		break;
	default:
		d++;
		break;
	}
```

そして生成したアセンブリ言語のコードが、こちら：

```asm
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)
	movl	-8(%ebp), %eax
	cmpl	$2, %eax
	je	.L3
	cmpl	$8, %eax
	je	.L4
	jmp	.L6
.L3:
	addl	$1, -4(%ebp)
	jmp	.L1
.L4:
	addl	$1, -8(%ebp)
	jmp	.L1
.L6:
	addl	$1, -12(%ebp)
.L1:
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    d => (ebp - 12) => -12(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# a = 4
# b = 8
# d = 0
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)

# tmp = b
	movl	-8(%ebp), %eax

# tmp と '2' を比較する
	cmpl	$2, %eax

# この比較が成功したらラベル L3 へジャンプする
# (ラベル L3 が switch ブロックの一番目の case ブロック)
	je	.L3

# tmp と '8' を比較する
	cmpl	$8, %eax

# この比較が成功したらラベル L4 へジャンプする
# (ラベル L4 が switch ブロックの二番目の case ブロック)
	je	.L4

# ここは default ブロック
# default ケースのコード（ラベル L6） へジャンプする
	jmp	.L6

# ここが一番目の case ブロックのコード
# a = a + 1
.L3:
	addl	$1, -4(%ebp)
	jmp	.L1

# ここが二番目の case ブロックのコード
# b = b + 1
.L4:
	addl	$1, -8(%ebp)
	jmp	.L1

# ここで default ブロックのコード
# d = d + 1
.L6:
	addl	$1, -12(%ebp)

# switch-case ブロック直後のラベル
.L1:
```

``default`` を除く 各 ``case`` ブロックの最後には switch-case ブロック直後のラベルへジャンプする命令があります。
このジャンプ命令が生成される理由は、C言語のコードの ``case`` ブロックの最後に ``break`` 文を書いたからです。
もし ``break`` 文を書かなかったら、このジャンプ命令は生成されず、次の case ブロックにあるコードが実行されるようになります。
この動きは C言語の仕様に準拠したものです。

---

## ループ処理の翻訳

#### <u>WHILE ループ</u>

この C言語のコードを例にとります。これは何かの関数の中から抜粋したコードです：

```C
	int a = 4;
	int b = 8;
	int d = 0;

	while (b > a) {
		d = a + 2;
		b--;
	}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)
	jmp	.L2
.L3:
	movl	-4(%ebp), %eax
	addl	$2, %eax
	movl	%eax, -12(%ebp)
	subl	$1, -8(%ebp)
.L2:
	movl	-8(%ebp), %eax
	cmpl	-4(%ebp), %eax
	jg	.L3
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    d => (ebp - 12) => -12(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：


```asm
# a = 4
# b = 8
# d = 0
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)

# ラベル L2 へジャンプする
# WHILE ループの条件をラベル L2 で評価する
	jmp	.L2

# WHILE 文の中にあるループブロックの先頭
.L3:

# tmp = a
	movl	-4(%ebp), %eax

# tmp = tmp + 2
	addl	$2, %eax

# d = tmp
	movl	%eax, -12(%ebp)

# b = b - 1
	subl	$1, -8(%ebp)

# WHILE 文を開始したら、ここで条件を評価する
.L2:

# tmp = b
	movl	-8(%ebp), %eax

# a と tmp を比較する
	cmpl	-4(%ebp), %eax

# tmp が a よりも大きい場合はループのブロック（ラベル L3）へジャンプする
	jg	.L3
```

#### <u>FOR ループ</u>

この C言語のコードを例にとります：

```C
	int a = 4;
	int b = 8;
	int d = 0;

	for (b = 9; b > a; b--) {
		d = a + 2;
	}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$4, -4(%ebp)
	movl	$8, -8(%ebp)
	movl	$0, -12(%ebp)
	movl	$9, -8(%ebp)
	jmp	.L2
.L3:
	movl	-4(%ebp), %eax
	addl	$2, %eax
	movl	%eax, -12(%ebp)
	subl	$1, -8(%ebp)
.L2:
	movl	-8(%ebp), %eax
	cmpl	-4(%ebp), %eax
	jg	.L3
```

生成したアセンブリ言語のコードの大部分は WHILE ループのそれと同じです。
ここには注目したい点を二つ紹介します：

* ループの初期条件をセットする命令が IF ブロック（比較命令）のコードよりも前に生成されている

* ループを更新していく命令が IF ブロック（比較命令）のコードの最後に生成されている

---

## ポインタの逆参照

この C言語のコードを例にとります：

```C
// これはグローバル宣言
int globalVar;

void f(void)
{
	int b;
	int *ptr;

	ptr = &globalVar;
	*ptr = 100;
	b = *ptr;
}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$globalVar, -4(%ebp)
	movl	-4(%ebp), %eax
	movl	$100, (%eax)
	movl	-4(%ebp), %eax
	movl	(%eax), %eax
	movl	%eax, -8(%ebp)
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    ptr => (ebp - 4) => -4(%ebp)
    b   => (ebp - 8) => -8(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# ptr = &globalVar
	movl	$globalVar, -4(%ebp)

# tmp = ptr
	movl	-4(%ebp), %eax

# *tmp = 100
	movl	$100, (%eax)

# tmp = ptr
	movl	-4(%ebp), %eax

# tmp = *tmp
	movl	(%eax), %eax

# b = tmp
	movl	%eax, -8(%ebp)
```

---

## 配列の操作

この C言語のコードを例にとります：

```C
// これはグローバル宣言
int globalVar[5];

void f(void)
{
	int b;
	int localArr[5];

	globalVar[2] = 12;
	localArr[0] = 3;
	localArr[4] = 18;
	b = localArr[4];
}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$12, globalVar+8
	movl	$3, -24(%ebp)
	movl	$18, -8(%ebp)
	movl	-8(%ebp), %eax
	movl	%eax, -4(%ebp)
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    b        => (ebp -  4) => -4(%ebp)
    localArr => (ebp - 24) から (ebp - 4) => -24(%ebp) から -4(%ebp) [但し -4(%ebp) が指すメモリは含まれない]

         配列 localArr のサイズは 5
         この配列の１要素のサイズは 4バイト
         従って配列 localArr[] は合計 20バイト
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# globalVar[2] = 12
# (globalVar + 8) は globalVar 変数の先頭から 8バイト目を示す
# この配列の要素は 4バイトなので三番目の要素はバイト・オフセット 8から始まる
	movl	$12, globalVar+8

# localArr[0] =3
# localArr 変数は -24(%ebp) から始まるので localArr[0] のバイト・オフセットは 0
	movl	$3, -24(%ebp)

# localArr[4] = 18
# localArr[4] はバイトオフセット 16（-24 + 16 = -8）
	movl	$18, -8(%ebp)

# tmp = localArr[4]
	movl	-8(%ebp), %eax

# b = tmp
	movl	%eax, -4(%ebp)
```

### ポインタを使った配列の操作


この C言語のコードを例にとります：

```C
// これはグローバル宣言
int globalVar[5];

void f(void)
{
	int b;
	int *ptr = globalVar;

	b = ptr[4];
}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$globalVar, -8(%ebp)
	movl	-8(%ebp), %eax
    addl    $16, %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    b   => (ebp - 4) => -4(%ebp)
    ptr => (ebp - 8) => -8(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# ptr = globalVar
	movl	$globalVar, -8(%ebp)

# tmp = ptr
    movl	-8(%ebp), %eax

# tmp = tmp + 16
# 現在 'tmp' にはポインタが格納されているので、次の命令はそのポインタを 16バイト移動する
    addl    $16, %eax

# tmp = *tmp
    movl	(%eax), %eax

# b = tmp
    movl	%eax, -4(%ebp)
```

---

## 関数ポインタの操作

この C言語のコードを例にとります：

```C
// これはグローバル宣言
void fun1(void)
{
}

void main(void)
{
	void (*fptr)() = fun1;
	fptr();
}
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$fun1, 12(%esp)
	movl	12(%esp), %eax
	call	*%eax
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    fptr => (ebp - 12) => -12(%ebp)
```

一時的な保管場所としてのレジスタの使い方については[ここ](/ch04-01-translation-of-arithmetic-operations.md#tempVaribaleUsage)で説明しました。

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# fptr = fun1
	movl	$fun1, 12(%esp)

# tmp = fptr
    movl	12(%esp), %eax

# ポインタを介して関数 tmp() を呼び出す
    call	*%eax
```

**注記：**

この例では ``ebp`` レジスタの代わりに ``esp`` レジスタを使ってローカル変数を参照しています。
スタックにのせる際に ``esp`` レジスタを使うか、または ``ebp`` レジスタを使うかは使用するコンパイラ次第です。

---

## 関数の呼び出し

C 言語における関数の呼び出しは ``call`` というアセンブリ言語の命令に翻訳されます。
CPU が ``call`` 命令を実行すると、次に実行する予定の命令をスタックに Push し、呼び出す関数の一番最初の命令に制御を渡します。
C 言語の ``return`` 文（C 言語の ``void`` 関数の最後にある明示的な ``return`` 文）はアセンブリ言語の ``ret`` 命令に翻訳されます。
この ``ret`` は関数を呼び出す命令とは「逆のこと」を行います。
すなわちスタックを Pop し「戻り先のアドレス」を取得して、そこへジャンプします。
そのため ``return`` 文を実行して戻り先の正しいアドレスが確実にスタックの先頭に積まれていることが重要になります。
ここで「戻り先のアドレス」をおかしくしてしまわぬよう正確なコードを生成するのはコンパイラの責任です。
では ``gcc`` コンパイラがどのようにして関数呼び出しのコードを生成するのか例を見てみることにしましょう。

C言語のコード：

```C
void fun(void)
{
	int x = 0;
	x++;
}

void main(void)
{
	fun();
}
```

これが生成したアセンブリ言語のコードです：

```asm
	.text
	.globl	fun

fun:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	$0, -4(%ebp)
	addl	$1, -4(%ebp)
	leave
	ret
	.globl	main
main:
	pushl	%ebp
	movl	%esp, %ebp
	call	fun
	popl	%ebp
	ret
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# ここが .text セグメントの先頭
	.text

# fun 関数を外部へエキスポートする
	.globl	fun

# fun 関数の先頭
fun:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	$0, -4(%ebp)
	addl	$1, -4(%ebp)
	leave
	ret

# main 関数を外部へエキスポートする
	.globl	main

# main 関数の先頭
main:
	pushl	%ebp
	movl	%esp, %ebp

# main 関数が fun 関数を呼び出す
	call	fun

# main 関数から戻る → ebp レジスタを戻してから呼び出し戻る
	popl	%ebp
	ret
```

---

## 引数渡しの処理

C言語の「引数」はスタックに渡されます。
関数の引数がスタックに Push されてから関数が呼び出されます。
これにより Push した引数はスタックの中で「戻り先のアドレス」の真下に格納されます。
したがって関数が引数を受け取る場合、スタックの中で「戻り先のアドレス」の真下から順番に読んでいけばよいことになります。

C言語のコード：

```C
void fun(int x, int y)
{
	x++;
	x += y;
}

void main(void)
{
	fun(2, 3);
}
```

これが生成したアセンブリ言語のコードです：

```asm
	.text
	.globl	fun
fun:
	pushl	%ebp
	movl	%esp, %ebp
	addl	$1, 8(%ebp)
	movl	12(%ebp), %eax
	addl	%eax, 8(%ebp)
	popl	%ebp
	ret
	.globl	main
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$8, %esp
	movl	$3, 4(%esp)
	movl	$2, (%esp)
	call	fun
	leave
	ret
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md)で説明しました）：

```
    x => (ebp -  8) => -8(%ebp)
    y => (ebp - 12) => -12(%ebp), %eax
```

これは「[スタックとローカル変数](/ch03-01-stack-and-local-variables.md)」の章で説明した内容と非常に関連があります。
引数はローカル変数として確保されます。
ただ一つ異なる点は、関数への引数を格納し、その上に「戻り先のアドレス」を Push したスタックの TOP（最上位）にローカル変数が確保されるということです。

引数渡しのスタック操作は、次の図を使って説明できます：

![](images/parameter.png)

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# ここが .text セグメントの先頭
	.text

# fun 関数を外部へエキスポートする
	.globl	fun

# fun 関数の先頭
fun:

# ebp レジスタの内容をスタックに退避する
	pushl	%ebp
	movl	%esp, %ebp

# x++;
	addl	$1, 8(%ebp)

# tmp = y
	movl	12(%ebp), %eax

# tmp = tmp + x
	addl	%eax, 8(%ebp)

# ebp レジスタの内容を復帰する
	popl	%ebp
	ret

# main 関数を外部へエキスポートする
	.globl	main

# main 関数の先頭
main:
# ebp レジスタの内容をスタックに退避する
	pushl	%ebp
	movl	%esp, %ebp

# スタックポインタ =- 8
	subl	$8, %esp

# 二番目の引数をスタックに格納する
	movl	$3, 4(%esp)

# 一番目の引数をスタックに格納する
	movl	$2, (%esp)

# fun 関数を呼び出す
	call	fun

# main 関数から戻る
	leave
	ret
```

理解すべきポイント：

* 言語の関数の引数は左から右の順に渡される。
最後の引数が最初にスタックに格納され、先頭の引数が最後に格納される。
そのためスタックを TOP（最上位）から参照していくと一番先頭の引数がまず最初に見つかる。

* C言語から生成されたアセンブリ言語のコードでは引数をスタックに格納する際に ``push`` 命令を使っていない。
その代わり、まずスタックポインタの位置を下位にずらし、そこで空いた領域に引数を ``movl`` 命令で格納している。
おそらくパフォーマンスの理由でこのような操作になっていると思われる
（``subl`` ＋ ``movl`` 命令の組み合わせは ``push`` 命令よりも高速なのだろう）。

* もし引数の型が構造体だったら、構造体全体がスタックに格納される。

---

## 関数の返り値


関数からの返り値はレジスタを介して返すか、あるいはスタックを介して返すかのどちらかです。
基本データ型（``int``、``char``、ポインタなど）のオブジェクトが返り値の場合は全て ``eax`` レジスタに格納します。
構造体型のオブジェクトが返り値の場合はスタックに格納します。

C言語のコード：

```C
int fun(void)
{
	return 16;
}

int main(void)
{
	int a;
	a = fun();
	return 0;
}
```

これが生成したアセンブリ言語のコードです：

```asm
	.text
	.globl	fun
fun:
	pushl	%ebp
	movl	%esp, %ebp
	movl	$16, %eax
	popl	%ebp
	ret
	.globl	main
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	call	fun
	movl	%eax, -4(%ebp)
	movl	$0, %eax
	leave
	ret
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# ここが .text セグメントの先頭
	.text

# fun 関数を外部へエキスポートする
	.globl	fun

# fun 関数の先頭
fun:

# ebp レジスタの内容をスタックに退避し、その ebp レジスタに現在のスタックポインタを格納する
	pushl	%ebp
	movl	%esp, %ebp

# 戻り値 (16) を eax レジスタに移動する
	movl	$16, %eax

# ebp レジスタの内容を戻してから呼び出し戻る
#
# 注記:
# return 命令はレジスタの内容を変更することはない
# この関数の呼び出し元が eax レジスタに格納された戻り値を受け取る
	popl	%ebp
	ret

# main 関数を外部へエキスポートする
	.globl	main

# main 関数の先頭
main:

# ebp レジスタの内容をスタックに退避し、その ebp レジスタに現在のスタックポインタを格納する
	pushl	%ebp
	movl	%esp, %ebp

# ローカル変数を作成し、esp レジスタを正しく整列させる
subl	$16, %esp

# fun 関数を呼び出す
	call	fun

# fun 関数からの戻り値は eax レジスタに格納されているので
# その内容をローカル変数（スタック）に格納する
	movl	%eax, -4(%ebp)

# ここで main 関数から戻る
# 返り値は eax レジスタの中に格納される
	movl	$0, %eax
	leave
	ret
```

---

## 構造体のメモリの確保

コードの中で、なにか構造体のオブジェクトを生成すると、コンパイラは「切れ目のない」連続したメモリをその構造体のデータ・メンバのために確保します。
確保するメモリのサイズは、「最低でも」全てのデータメンバのサイズを足したものになります。
その際にコンパイラは「パディング」を使用して、二つのデータ・メンバの間に未使用の領域を生成することができます。
この「パディング」は構造体のデータ・メンバに高速にアクセスできるようにメンバを配置するために行われるものです。
但し、パディングの動きを制御し、コンパイラを停止することで余分な領域を確保できます。
構造体のデータ・メンバには構造体のベースアドレスと構造体の中でのオフセットを使ってアクセスします。

それでは、これを例を使って見てみることにしましょう。

C言語のコード：

```C
struct data_struct
{
	int a;
	int b;
};

struct data_struct global_data;

int main(void)
{
	struct data_struct local_data;
	global_data.a = 10;
	global_data.b = 15;

	local_data.a = 25;
	local_data.b = 20;

	return 0;
}
```

これが生成したアセンブリ言語のコードです：

```asm
	.comm	global_data,8,4
	.text
	.globl	main
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	$10, global_data
	movl	$15, global_data+4
	movl	$25, -8(%ebp)
	movl	$20, -4(%ebp)
	movl	$0, %eax
	leave
	ret
```

構造体の中のメンバに対するオフセットは、次のとおりです：

```
    a => 0
    b => 4
```

``global_data`` のメンバへのアクセス方法は、次のとおりです：

```
    global_data.a => global_data+0 （または単に global_data）
    global_data.b => global_data+4
```

``local_data`` のメンバへのアクセス方法は、次のとおりです：

```
    local_data.a => (ebp - 8) => -8(%ebp)
    local_data.b => (ebp - 4) => -4(%ebp)
```

``local_data`` はスタックの -8(%ebp) から %(%ebp) のメモリ空間に確保されます。
ローカル変数の確保については[ここ](/ch03-01-stack-and-local-variables.md)を参照して下さい。


### 構造体とパディング

コンパイラは構造体にある二つのデータ・メンバの間に空の領域をいくつか確保して、各メンバに高速にアクセスできるようにします。
これを「パディング」と呼びます。
メンバ同士の境界に確保される空の領域のサイズはランタイムで使用するプロセッサのアーキテクチャに依存します。

これを例を使って見てみることにしましょう。

```C
struct data_struct
{
	char a;
	int b;
};
```

i386 アーキテクチャの場合 ``sizeof()`` 演算子を使って、ここで定義した構造体のサイズを取得すると、8 が返ってきます。
しかし机上では ``sizeof(char)`` の返り値は 1、そして ``sizeof(int)`` の返り値は 4 なので合計は 5バイトのはずですが、コンパイラが実際に確保したのは 8バイトです。
すなわち ``char`` 型のメンバにも 4バイト確保されていたのです。

ここで構造体を次のように宣言してみます：

```C
struct data_struct
{
	char a;
	int b;
} __attribute__((packed));
```

すると i386 アーキテクチャの場合 ``sizeof(struct data_struct)`` の返り値は 5になります。
`` __attribute__((packed))`` はコンパイラにパディングしないよう強制して無駄な空き領域を確保しないようにします。
また ``__attribute__()`` は構造体の中にあるデータ・メンバごとに指定することも可能です。

例えば：

```C
struct data_struct
{
	char a;
	int b __attribute__((packed));
};
```

この宣言は構造体のデータ・メンバ ``a`` と ``b`` の間はパディングしないと言う意味です。
``__attribute__()`` は境界線を増やす際にも使用できます。
詳細についてはコンパイラのドキュメントを参照してみて下さい。

### 関数から構造体を返す

既に[ここ](/ch13-01-returning-value-from-function.md)で、基本データ型の場合は``eax`` レジスタを介して関数からの返り値を受け取ることを説明しました。
しかし構造体の場合は ``eax`` レジスタで返すことはできません。
なぜなら ``eax`` レジスタのサイズは 4バイト固定であり、構造体のサイズは任意だからです。
関数から構造体を返り値にするには、コンパイラが別の方法を使う必要があります。

それでは、このような時に ``gcc`` コンパイラがどのように動くか例を使って見てみることにしましょう：

```C
struct data_struct
{
	int a;
	int b;
};

struct data_struct
fun(void)
{
	struct data_struct data;
	data.a = 20;
	data.b = 25;
	return data;
}

int main (void)
{
	struct data_struct local_data = fun();
	return 0;
}
```

これが生成したアセンブリ言語のコードです：

```asm
	.text
	.globl	fun
fun:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	$20, -8(%ebp)
	movl	$25, -4(%ebp)
	movl	8(%ebp), %ecx
	movl	-8(%ebp), %eax
	movl	-4(%ebp), %edx
	movl	%eax, (%ecx)
	movl	%edx, 4(%ecx)
	movl	8(%ebp), %eax
	leave
	ret	$4
	.globl	main
main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$20, %esp
	leal	-8(%ebp), %eax
	movl	%eax, (%esp)
	call	fun
	subl	$4, %esp
	movl	$0, %eax
	leave
	ret
```

このアセンブリ言語のコードと等価なC言語のプログラムを次のように作成し直すこともできます：

```C
void
fun(struct data_struct *ptr)
{
	struct data_struct data;
	data.a = 20;
	data.b = 25;
	ptr->a = data.a;
	ptr->b = data.b;
}

int main (void)
{
	struct data_struct data;
	fun(&data);
	return 0;
}
```

コンパイラは ``data`` を返す関数に構造体へのポインタを一つ渡します。
ここで注意したい点が二つあります。

* 構造体を返す関数の型は ``void`` とする。
すなわち ``eax`` レジスタ経由では構造体を返さない。

* 関数は構造体を指すポインタ型を引数として受け取る。

---

## C言語とアセンブリ言語の連携

### アセンブリ言語で定義したものをC言語で使う

これが関数と変数を実装したアセンブリ言語のコードです：

```asm
# asm_var と言うグローバル変数を定義して公開することで、それを C言語のコードから利用できるようになる
.data
.global asm_var
asm_var:
.long

# asm_fun() という関数を定義して公開することで、それを C言語のコードから利用できるようになる
.text
.global asm_fun
asm_fun:
    ret;
```

そして C言語のコード：

```C
void asm_fun();
extern int asm_var;

int x;

void
main (void)
{
	asm_fun();
	asm_var++;
}
```

理解すべきポイント：

* アセンブリ言語のコードに、C言語のプログラムから利用することが可能な変数や関数を定義できる。
* アセンブリ言語のコードで、C言語のプログラムから利用できる変数や関数を「公開」すること。
この例では ``.global`` 属性を使用して ``asm_var`` と ``asm_fun()`` を公開している。
* C言語のコードは実際に使用する前に公開されている変数や関数を宣言しておく。
これらの宣言は、通常のヘッダファイルの中でやっていることに似ている。
宣言は C言語のソースファイルか、またはヘッダファイルの中で行う。


### C言語で定義したものをアセンブリ言語で使う

まず C言語のコード：

```C
void
fun(void)
{

}
```

次に、上の関数を呼び出すアセンブリ言語のコード：

```asm
	.text
	.globl	main
main:
	call fun
	ret;
```

理解すべきポイント：

* C言語のコードの中で定義した関数と変数は ``static`` キーワードを使わない限り、自動的に外部に公開される。
従って前述のアセンブリ言語のコードの中で実施したように、一つ一つ明示的に公開する必要はない。
* アセンブリ言語では、たとえアセンブリ言語の中で関数や変数が定義されていたとしても、そのまま関数を呼び出したり変数を利用することができる。

### C言語のコードの中にアセンブリ言語のコードを埋め込む

C言語だけでは解決できないことがいくつかあります。
そのような時はアセンブリ言語を使うことになります。
例えばハードウェアの例外を発生させたいような場合、アセンブリ言語で命令を記述する必要がでてきます。
C言語では（API を利用しない限り）ハードウェアの例外を発生させる命令を提供できません。
そのため別のファイルにアセンブリ言語のコードを用意し、C言語のコードから呼び出します。
C言語には、アセンブリ言語のコードを C言語のコードの中に挿入する機能があります。
これを実現する際は ``asm`` キーワードを使います。

これがサンプルコードです：

```C
int main (void)
{
	asm("int $3");
	return 0;
}
```

この C言語のコードから生成したアセンブリ言語のコードが、こちらです：


```asm
	.text
	.globl	main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	int $3
	movl	$0, %eax
	popl	%ebp
	ret
```

---

## その他

### 特定のセグメントの中にコードを生成する

``gcc`` コンパイラは ``.text`` セグメントの中にアセンブリ言語のコードを格納し、``.data`` または ``.bss`` セグメントの中にはグローバル変数を格納します。
``gcc`` が関数やグローバル変数といった類のコードを、どのセグメントに格納するかといったルールが予め決められています。
プログラマは、この振る舞いをオーバーライドできます。
セグメントは制御が可能です。

例を使って見てみることにしましょう。

これが C言語のコードです：

```C
void __attribute__((section ("MySegment")))
fun(void)
{
}

int main (void)
{
	fun();
	return 0;
}
```

このファイルを ``gcc`` でコンパイルして ``a.out`` ファイルを生成して下さい。
そして ``objdump`` コマンドを次のようにして ``a.out`` ファイルを調査します：


```
$ objdump -h a.out
```

このコマンドは ``a.out`` の内部にあるいろいろなセグメントの一覧を表示します。
"MySegment" と云うセグメントがあるはずです。
``__attribute__`` はグローバル変数に適用できます。

---

## おわりに


この「C言語インターナル (*C Internals*)」では ``gcc`` コンパイラのコード生成の詳細について説明しました。
C言語のコードがどのようにアセンブリ言語に翻訳されるのかを説明しました。
コンパイラの内部とコードの生成について理解しておくと、いろいろなところで役に立ちます。
しばしば問題解析やデバッグ、そしてリバース・エンジニアリングなどで助けになることでしょう。


### 次のステップは？

より深く理解するために、Cコンパイラによって生成されたコードを読む習慣を身につけて下さい。
ここで、逆アセンブルしたコードを読む方法を二つ紹介します：

* ``gcc`` コンパイラで ``-S`` オプションを付ける。
これで ``gcc`` コンパイラは C言語のソースファイルからアセンブリ言語のコードを生成する。
* いろいろなバイナリ・ファイルを ``objdump`` コマンドを使って逆アセンブルしてみる。

**ここで便利なツール：**

``ld``、``objdump``、``readelf``、``objcopy``、``nm``、``strip``、``ldd``


### フィードバック

私（著者）にメールでご意見・ご感想をお送り下さい。
Gmail ID の rajeevku02 で連絡がとれます。

